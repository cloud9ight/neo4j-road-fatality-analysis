// part1: Load Script: Create Constraints and Load Data
// =======================================================================
// CSV files are in Neo4j 'import' directory
// Run each block in Neo4j Browser
// =======================================================================

// --- block 1. Create Constraints ---
CREATE CONSTRAINT unique_person_id IF NOT EXISTS FOR (p:Person) REQUIRE p.personID IS UNIQUE;
CREATE CONSTRAINT unique_crash_id IF NOT EXISTS FOR (c:Crash) REQUIRE c.internalCrashID IS UNIQUE;
CREATE CONSTRAINT unique_lga_name IF NOT EXISTS FOR (l:LGA) REQUIRE l.name IS UNIQUE;
CREATE CONSTRAINT unique_sa4_name IF NOT EXISTS FOR (s4:SA4) REQUIRE s4.name IS UNIQUE;
CREATE CONSTRAINT unique_state_name IF NOT EXISTS FOR (st:State) REQUIRE st.name IS UNIQUE;

// --- 2. Load Nodes ---

// 1a. Load States
LOAD CSV WITH HEADERS FROM 'file:///states.csv' AS row FIELDTERMINATOR ','
MERGE (st:State {name: row.`name:ID(State)`});

// 2b. Load SA4 Regions
LOAD CSV WITH HEADERS FROM 'file:///sa4s.csv' AS row FIELDTERMINATOR ','
MERGE (s4:SA4 {name: row.`name:ID(SA4)`});

// 2c: Load LGAs 
LOAD CSV WITH HEADERS FROM 'file:///lgas.csv' AS row FIELDTERMINATOR ','
MERGE (l:LGA {name: row.`name:ID(LGA)`});

// 2d: Load Persons 
LOAD CSV WITH HEADERS FROM 'file:///persons.csv' AS row FIELDTERMINATOR ','
MERGE (p:Person {personID: toInteger(row.`personID:ID(Person)`)})
ON CREATE SET p.roadUser = row.roadUser, p.gender = row.gender, p.age = toInteger(row.age), p.ageGroup = row.ageGroup
ON MATCH SET p.roadUser = row.roadUser, p.gender = row.gender, p.age = toInteger(row.age), p.ageGroup = row.ageGroup;

// 2e: Load Crashes 
LOAD CSV WITH HEADERS FROM 'file:///crashes.csv' AS row FIELDTERMINATOR ','
MERGE (c:Crash {internalCrashID: toInteger(row.`internalCrashID:ID(Crash)`)})
ON CREATE SET c.crashID_orig = row.crashID_orig, c.year = toInteger(row.year), c.month = toInteger(row.month), c.dayweek = row.dayweek, c.time = row.time, c.crashType = row.crashType, c.numberFatalities = toInteger(row.numberFatalities), c.busInvolvement = row.busInvolvement, c.heavyRigidTruckInvolvement = row.heavyRigidTruckInvolvement, c.articulatedTruckInvolvement = row.articulatedTruckInvolvement, c.speedLimit = CASE WHEN row.speedLimit IS NULL OR row.speedLimit = '' THEN null ELSE toInteger(row.speedLimit) END, c.nationalRoadType = row.nationalRoadType, c.christmasPeriod = row.christmasPeriod, c.easterPeriod = row.easterPeriod, c.nationalRemotenessAreas = row.nationalRemotenessAreas, c.dayOfWeekType = row.dayOfWeekType, c.timeOfDay = row.timeOfDay
ON MATCH SET c.crashID_orig = row.crashID_orig, c.year = toInteger(row.year), c.month = toInteger(row.month), c.dayweek = row.dayweek, c.time = row.time, c.crashType = row.crashType, c.numberFatalities = toInteger(row.numberFatalities), c.busInvolvement = row.busInvolvement, c.heavyRigidTruckInvolvement = row.heavyRigidTruckInvolvement, c.articulatedTruckInvolvement = row.articulatedTruckInvolvement, c.speedLimit = CASE WHEN row.speedLimit IS NULL OR row.speedLimit = '' THEN null ELSE toInteger(row.speedLimit) END, c.nationalRoadType = row.nationalRoadType, c.christmasPeriod = row.christmasPeriod, c.easterPeriod = row.easterPeriod, c.nationalRemotenessAreas = row.nationalRemotenessAreas, c.dayOfWeekType = row.dayOfWeekType, c.timeOfDay = row.timeOfDay;

// --- 3. Load Relationships ---

// 3a: SA4 -> State 

LOAD CSV WITH HEADERS FROM 'file:///rels_sa4_state.csv' AS row FIELDTERMINATOR ','
MATCH (s4:SA4 {name: row.`:START_ID(SA4)`})
MATCH (st:State {name: row.`:END_ID(State)`})
MERGE (s4)-[r:IN_STATE]->(st);

// 3b: LGA -> SA4 

LOAD CSV WITH HEADERS FROM 'file:///rels_lga_sa4.csv' AS row FIELDTERMINATOR ','
MATCH (l:LGA {name: row.`:START_ID(LGA)`})
MATCH (s4:SA4 {name: row.`:END_ID(SA4)`})
MERGE (l)-[r:PART_OF]->(s4);

// 3c: Crash -> LGA 

LOAD CSV WITH HEADERS FROM 'file:///rels_crash_lga.csv' AS row FIELDTERMINATOR ','
MATCH (c:Crash {internalCrashID: toInteger(row.`:START_ID(Crash)`)})
MATCH (l:LGA {name: row.`:END_ID(LGA)`})
MERGE (c)-[r:OCCURRED_IN]->(l);

// 3d: Person -> Crash 

LOAD CSV WITH HEADERS FROM 'file:///rels_person_crash.csv' AS row FIELDTERMINATOR ','
MATCH (p:Person {personID: toInteger(row.`:START_ID(Person)`)})
MATCH (c:Crash {internalCrashID: toInteger(row.`:END_ID(Crash)`)})
MERGE (p)-[r:WAS_INVOLVED_IN]->(c);

// --- Create Indexes (for better performance) ---
CREATE INDEX idx_crash_year IF NOT EXISTS FOR (c:Crash) ON (c.year);
CREATE INDEX idx_crash_trucks IF NOT EXISTS FOR (c:Crash) ON (c.articulatedTruckInvolvement, c.busInvolvement, c.heavyRigidTruckInvolvement);
CREATE INDEX idx_crash_timeofday IF NOT EXISTS FOR (c:Crash) ON (c.timeOfDay);
CREATE INDEX idx_crash_dayweektype IF NOT EXISTS FOR (c:Crash) ON (c.dayOfWeekType);
CREATE INDEX idx_crash_holiday IF NOT EXISTS FOR (c:Crash) ON (c.christmasPeriod, c.easterPeriod);
CREATE INDEX idx_crash_remoteness IF NOT EXISTS FOR (c:Crash) ON (c.nationalRemotenessAreas);
CREATE INDEX idx_crash_speed IF NOT EXISTS FOR (c:Crash) ON (c.speedLimit);
CREATE INDEX idx_crash_time IF NOT EXISTS FOR (c:Crash) ON (c.time);
CREATE INDEX idx_person_agegroup IF NOT EXISTS FOR (p:Person) ON (p.ageGroup);
CREATE INDEX idx_person_roaduser IF NOT EXISTS FOR (p:Person) ON (p.roadUser);
CREATE INDEX idx_person_gender IF NOT EXISTS FOR (p:Person) ON (p.gender);


// =======================================================================
// part2: Query
// =======================================================================

// --a. WA Crashes (2020-2024), Articulated Trucks, Multiple Fatalities

MATCH (p:Person)-[:WAS_INVOLVED_IN]->(c:Crash)-[:OCCURRED_IN]->(l:LGA)-[:PART_OF]->(:SA4)-[:IN_STATE]->(st:State {name: 'WA'})
WHERE c.year >= 2020 AND c.year <= 2024
  AND c.articulatedTruckInvolvement = 'yes'
  AND c.numberFatalities > 1
RETURN DISTINCT 
       c.crashID_orig AS CrashID,
       p.personID AS PersonID,       
       p.roadUser AS RoadUser,
       p.age AS Age,
       p.gender AS Gender,
       l.name AS LGAName,
       c.month AS Month,
       c.year AS Year,
       c.numberFatalities AS TotalFatalitiesInCrash
ORDER BY CrashID, PersonID; 


// --b. Max/Min Age, Motorcycle Riders, Holiday Periods, Inner Regional

MATCH (p:Person {roadUser: 'Motorcycle rider'})-[:WAS_INVOLVED_IN]->(c:Crash)
WHERE (c.christmasPeriod = 'yes' OR c.easterPeriod = 'yes') 
  AND c.nationalRemotenessAreas = 'Inner Regional Australia' 
  AND p.gender IN ['Male', 'Female'] 
  AND p.age IS NOT NULL 
RETURN p.gender AS Gender,
       max(p.age) AS MaximumAge,
       min(p.age) AS MinimumAge;

// --c. Young Drivers (17-25), Weekend/Weekday Counts per State (2024), Avg Age

MATCH (p:Person { 
           ageGroup: '17_to_25', 
           roadUser: 'Driver' 
       })
       -[:WAS_INVOLVED_IN]->(c:Crash)
       -[:OCCURRED_IN]->(:LGA)
       -[:PART_OF]->(:SA4)
       -[:IN_STATE]->(st:State)
WHERE c.year = 2024 
RETURN st.name AS StateName,
       SUM(CASE c.dayOfWeekType WHEN 'Weekend' THEN 1 ELSE 0 END) AS WeekendFatalities,
       SUM(CASE c.dayOfWeekType WHEN 'Weekday' THEN 1 ELSE 0 END) AS WeekdayFatalities,
       avg(p.age) AS AverageAgeYoungDriver

// --d. WA, Friday (Weekend Category), Multi-Death, Male & Female Victims

MATCH (c:Crash)-[:OCCURRED_IN]->(:LGA)-[:PART_OF]->(s4:SA4)-[:IN_STATE]->(st:State {name: 'WA'})
WHERE c.dayweek = 'Friday'
  AND c.dayOfWeekType = 'Weekend'
  AND c.numberFatalities > 1
WITH c, s4
WHERE EXISTS { (p_male:Person {gender: 'Male'})-[:WAS_INVOLVED_IN]->(c) }
  AND EXISTS { (p_female:Person {gender: 'Female'})-[:WAS_INVOLVED_IN]->(c) }
RETURN DISTINCT s4.name AS SA4_Name,
              c.nationalRemotenessAreas AS NationalRemotenessArea,
              c.nationalRoadType AS NationalRoadType
ORDER BY SA4_Name;

// --e. Top 5 SA4 Regions by Fatal Crashes during Peak Hours

MATCH (c:Crash)-[:OCCURRED_IN]->(:LGA)-[:PART_OF]->(s4:SA4)
WITH c, s4, time(c.time) AS crashTime 
WHERE (crashTime >= time('07:00') AND crashTime <= time('09:00')) 
   OR (crashTime >= time('16:00') AND crashTime <= time('18:00')) 
WITH s4, crashTime 
RETURN s4.name AS SA4_Region,
       count(CASE WHEN crashTime >= time('07:00') AND crashTime <= time('09:00') THEN 1 END) AS MorningPeak,
       count(CASE WHEN crashTime >= time('16:00') AND crashTime <= time('18:00') THEN 1 END) AS AfternoonPeak

ORDER BY (MorningPeak + AfternoonPeak) DESC
LIMIT 5;

// --f. Top 3 Paths of Length 3 between any two LGAs

MATCH path = (lga1:LGA)-[*]-(lga2:LGA)
WHERE elementId(lga1) < elementId(lga2) 
  AND length(path) = 3
RETURN lga1.name AS StartLGA,
       lga2.name AS EndLGA
ORDER BY StartLGA ASC, EndLGA ASC
LIMIT 3;

// --g. Weekday Pedestrian Crashes, Bus/HeavyRigid Involved, Specific Speed Zones

MATCH (p:Person {roadUser: 'Pedestrian'})-[:WAS_INVOLVED_IN]->(c:Crash)
WHERE c.dayOfWeekType = 'Weekday'
  AND (c.busInvolvement = 'yes' OR c.heavyRigidTruckInvolvement = 'yes') 
  AND (c.speedLimit < 40 OR c.speedLimit >= 100)
  AND c.speedLimit IS NOT NULL AND p.ageGroup IS NOT NULL AND c.timeOfDay IS NOT NULL
WITH p, c,
   CASE
     WHEN c.busInvolvement = 'yes' AND c.heavyRigidTruckInvolvement = 'yes' THEN 'Bus and Heavy Rigid'
     WHEN c.busInvolvement = 'yes' THEN 'Bus'
     WHEN c.heavyRigidTruckInvolvement = 'yes' THEN 'Heavy Rigid Truck'
     ELSE 'Other' 
   END AS vehicleType
RETURN c.timeOfDay AS TimeOfDay,
       p.ageGroup AS AgeGroup,
       vehicleType AS VehicleType,
       c.speedLimit AS SpeedLimitation,
       count(DISTINCT c.internalCrashID) AS CrashCount
ORDER BY
  CASE c.timeOfDay WHEN 'Day' THEN 1 WHEN 'Night' THEN 2 ELSE 3 END ASC, 
  p.ageGroup ASC, 
  VehicleType ASC,
  SpeedLimitation ASC;


// -- self-designed query --
// --h1. Compare High-Speed vs. Low/Medium-Speed Zones

MATCH (p:Person {roadUser: 'Driver'})-[:WAS_INVOLVED_IN]->(c:Crash)
WITH p.ageGroup AS DriverAgeGroup, c.speedLimit AS speedLimit
RETURN DriverAgeGroup,
       count(CASE WHEN speedLimit >= 100 THEN 1 END) AS HighSpeedFatalities,
       count(CASE WHEN speedLimit < 100 THEN 1 END) AS LowerSpeedFatalities
ORDER BY DriverAgeGroup;

// --h2. Heavy Vehicle Crashes by Remoteness Area

MATCH (c:Crash)
WHERE (c.busInvolvement = 'yes'
   OR c.heavyRigidTruckInvolvement = 'yes'
   OR c.articulatedTruckInvolvement = 'yes')
  AND c.nationalRemotenessAreas IS NOT NULL
RETURN c.nationalRemotenessAreas AS RemotenessArea,
       count(c) AS HeavyVehicleCrashCount
ORDER BY HeavyVehicleCrashCount DESC;

// --h3. High-Risk Pattern 

MATCH (p:Person {ageGroup: '17_to_25', roadUser: 'Driver'})
       -[:WAS_INVOLVED_IN]->(c:Crash {nationalRoadType: 'National or State Highway'}) // Filter Road Type here
       -[:OCCURRED_IN]->(:LGA)-[:PART_OF]->(:SA4)-[:IN_STATE]->(st:State)
WHERE c.nationalRemotenessAreas <> 'Major Cities of Australia' // Exclude Major Cities
WITH st.name AS State,
     c.nationalRemotenessAreas AS RemotenessArea,
     count(DISTINCT c.internalCrashID) AS HighwayCrashCount 

WHERE HighwayCrashCount > 10 // Keep only combinations with more than 10 crashes

RETURN State,
       RemotenessArea,
       HighwayCrashCount
ORDER BY State ASC, HighwayCrashCount DESC;

// --h4. Analyzing Secondary Fatalities in Multi-Fatality Crashes

MATCH (p_driver:Person {ageGroup: '17_to_25', roadUser: 'Driver'})
       -[:WAS_INVOLVED_IN]->(c:Crash)
WHERE c.numberFatalities > 1 
WITH c 
MATCH (p_other)-[:WAS_INVOLVED_IN]->(c) // Find anyone involved in that crash 'c'

WHERE p_other.roadUser IS NOT NULL AND p_other.ageGroup IS NOT NULL
     
RETURN p_other.roadUser AS OtherVictimRoadUser,
       p_other.ageGroup AS OtherVictimAgeGroup,
       count(p_other) AS CoFatalityCount // Count the other victims
ORDER BY CoFatalityCount DESC
LIMIT 20; 